{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { _generateLinkResponse, _noResolveJsonResponse, _request, _userResponse } from './lib/fetch';\nimport { resolveFetch } from './lib/helpers';\nimport { isAuthError } from './lib/errors';\nexport default class GoTrueAdminApi {\n  constructor(_ref) {\n    let {\n      url = '',\n      headers = {},\n      fetch\n    } = _ref;\n    this.url = url;\n    this.headers = headers;\n    this.fetch = resolveFetch(fetch);\n    this.mfa = {\n      listFactors: this._listFactors.bind(this),\n      deleteFactor: this._deleteFactor.bind(this)\n    };\n  }\n  /**\n   * Removes a logged-in session.\n   * @param jwt A valid, logged-in JWT.\n   * @param scope The logout sope.\n   */\n\n\n  async signOut(jwt) {\n    let scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'global';\n\n    try {\n      await _request(this.fetch, 'POST', `${this.url}/logout?scope=${scope}`, {\n        headers: this.headers,\n        jwt,\n        noResolveJson: true\n      });\n      return {\n        data: null,\n        error: null\n      };\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: null,\n          error\n        };\n      }\n\n      throw error;\n    }\n  }\n  /**\n   * Sends an invite link to an email address.\n   * @param email The email address of the user.\n   * @param options Additional options to be included when inviting.\n   */\n\n\n  async inviteUserByEmail(email) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/invite`, {\n        body: {\n          email,\n          data: options.data\n        },\n        headers: this.headers,\n        redirectTo: options.redirectTo,\n        xform: _userResponse\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: {\n            user: null\n          },\n          error\n        };\n      }\n\n      throw error;\n    }\n  }\n  /**\n   * Generates email links and OTPs to be sent via a custom email provider.\n   * @param email The user's email.\n   * @param options.password User password. For signup only.\n   * @param options.data Optional user metadata. For signup only.\n   * @param options.redirectTo The redirect url which should be appended to the generated link\n   */\n\n\n  async generateLink(params) {\n    try {\n      const {\n        options\n      } = params,\n            rest = __rest(params, [\"options\"]);\n\n      const body = Object.assign(Object.assign({}, rest), options);\n\n      if ('newEmail' in rest) {\n        // replace newEmail with new_email in request body\n        body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;\n        delete body['newEmail'];\n      }\n\n      return await _request(this.fetch, 'POST', `${this.url}/admin/generate_link`, {\n        body: body,\n        headers: this.headers,\n        xform: _generateLinkResponse,\n        redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: {\n            properties: null,\n            user: null\n          },\n          error\n        };\n      }\n\n      throw error;\n    }\n  } // User Admin API\n\n  /**\n   * Creates a new user.\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n\n\n  async createUser(attributes) {\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/admin/users`, {\n        body: attributes,\n        headers: this.headers,\n        xform: _userResponse\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: {\n            user: null\n          },\n          error\n        };\n      }\n\n      throw error;\n    }\n  }\n  /**\n   * Get a list of users.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.\n   */\n\n\n  async listUsers(params) {\n    var _a, _b, _c, _d, _e, _f, _g;\n\n    try {\n      const pagination = {\n        nextPage: null,\n        lastPage: 0,\n        total: 0\n      };\n      const response = await _request(this.fetch, 'GET', `${this.url}/admin/users`, {\n        headers: this.headers,\n        noResolveJson: true,\n        query: {\n          page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '',\n          per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''\n        },\n        xform: _noResolveJsonResponse\n      });\n      if (response.error) throw response.error;\n      const users = await response.json();\n      const total = (_e = response.headers.get('x-total-count')) !== null && _e !== void 0 ? _e : 0;\n      const links = (_g = (_f = response.headers.get('link')) === null || _f === void 0 ? void 0 : _f.split(',')) !== null && _g !== void 0 ? _g : [];\n\n      if (links.length > 0) {\n        links.forEach(link => {\n          const page = parseInt(link.split(';')[0].split('=')[1].substring(0, 1));\n          const rel = JSON.parse(link.split(';')[1].split('=')[1]);\n          pagination[`${rel}Page`] = page;\n        });\n        pagination.total = parseInt(total);\n      }\n\n      return {\n        data: Object.assign(Object.assign({}, users), pagination),\n        error: null\n      };\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: {\n            users: []\n          },\n          error\n        };\n      }\n\n      throw error;\n    }\n  }\n  /**\n   * Get user by id.\n   *\n   * @param uid The user's unique identifier\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n\n\n  async getUserById(uid) {\n    try {\n      return await _request(this.fetch, 'GET', `${this.url}/admin/users/${uid}`, {\n        headers: this.headers,\n        xform: _userResponse\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: {\n            user: null\n          },\n          error\n        };\n      }\n\n      throw error;\n    }\n  }\n  /**\n   * Updates the user data.\n   *\n   * @param attributes The data you want to update.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n\n\n  async updateUserById(uid, attributes) {\n    try {\n      return await _request(this.fetch, 'PUT', `${this.url}/admin/users/${uid}`, {\n        body: attributes,\n        headers: this.headers,\n        xform: _userResponse\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: {\n            user: null\n          },\n          error\n        };\n      }\n\n      throw error;\n    }\n  }\n  /**\n   * Delete a user. Requires a `service_role` key.\n   *\n   * @param id The user id you want to remove.\n   * @param shouldSoftDelete If true, then the user will be soft-deleted (setting `deleted_at` to the current timestamp and disabling their account while preserving their data) from the auth schema.\n   * Defaults to false for backward compatibility.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n\n\n  async deleteUser(id) {\n    let shouldSoftDelete = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    try {\n      return await _request(this.fetch, 'DELETE', `${this.url}/admin/users/${id}`, {\n        headers: this.headers,\n        body: {\n          should_soft_delete: shouldSoftDelete\n        },\n        xform: _userResponse\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: {\n            user: null\n          },\n          error\n        };\n      }\n\n      throw error;\n    }\n  }\n\n  async _listFactors(params) {\n    try {\n      const {\n        data,\n        error\n      } = await _request(this.fetch, 'GET', `${this.url}/admin/users/${params.userId}/factors`, {\n        headers: this.headers,\n        xform: factors => {\n          return {\n            data: {\n              factors\n            },\n            error: null\n          };\n        }\n      });\n      return {\n        data,\n        error\n      };\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: null,\n          error\n        };\n      }\n\n      throw error;\n    }\n  }\n\n  async _deleteFactor(params) {\n    try {\n      const data = await _request(this.fetch, 'DELETE', `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {\n        headers: this.headers\n      });\n      return {\n        data,\n        error: null\n      };\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: null,\n          error\n        };\n      }\n\n      throw error;\n    }\n  }\n\n}","map":{"version":3,"mappings":";;;;;;;;;;;AAAA,SAEEA,qBAFF,EAGEC,sBAHF,EAIEC,QAJF,EAKEC,aALF,QAMO,aANP;AAOA,SAASC,YAAT,QAA6B,eAA7B;AAeA,SAAoBC,WAApB,QAAuC,cAAvC;AAEA,eAAc,MAAOC,cAAP,CAAqB;EAUjCC,kBAUC;IAAA,IAVW;MACVC,GAAG,GAAG,EADI;MAEVC,OAAO,GAAG,EAFA;MAGVC;IAHU,CAUX;IACC,KAAKF,GAAL,GAAWA,GAAX;IACA,KAAKC,OAAL,GAAeA,OAAf;IACA,KAAKC,KAAL,GAAaN,YAAY,CAACM,KAAD,CAAzB;IACA,KAAKC,GAAL,GAAW;MACTC,WAAW,EAAE,KAAKC,YAAL,CAAkBC,IAAlB,CAAuB,IAAvB,CADJ;MAETC,YAAY,EAAE,KAAKC,aAAL,CAAmBF,IAAnB,CAAwB,IAAxB;IAFL,CAAX;EAID;EAED;;;;;;;EAKa,MAAPG,OAAO,CACXC,GADW,EAEoC;IAAA,IAA/CC,KAA+C,uEAAR,QAAQ;;IAE/C,IAAI;MACF,MAAMjB,QAAQ,CAAC,KAAKQ,KAAN,EAAa,MAAb,EAAqB,GAAG,KAAKF,GAAG,iBAAiBW,KAAK,EAAtD,EAA0D;QACtEV,OAAO,EAAE,KAAKA,OADwD;QAEtES,GAFsE;QAGtEE,aAAa,EAAE;MAHuD,CAA1D,CAAd;MAKA,OAAO;QAAEC,IAAI,EAAE,IAAR;QAAcC,KAAK,EAAE;MAArB,CAAP;IACD,CAPD,CAOE,OAAOA,KAAP,EAAc;MACd,IAAIjB,WAAW,CAACiB,KAAD,CAAf,EAAwB;QACtB,OAAO;UAAED,IAAI,EAAE,IAAR;UAAcC;QAAd,CAAP;MACD;;MAED,MAAMA,KAAN;IACD;EACF;EAED;;;;;;;EAKuB,MAAjBC,iBAAiB,CACrBC,KADqB,EAQf;IAAA,IANNC,OAMM,uEAAF,EAAE;;IAEN,IAAI;MACF,OAAO,MAAMvB,QAAQ,CAAC,KAAKQ,KAAN,EAAa,MAAb,EAAqB,GAAG,KAAKF,GAAG,SAAhC,EAA2C;QAC9DkB,IAAI,EAAE;UAAEF,KAAF;UAASH,IAAI,EAAEI,OAAO,CAACJ;QAAvB,CADwD;QAE9DZ,OAAO,EAAE,KAAKA,OAFgD;QAG9DkB,UAAU,EAAEF,OAAO,CAACE,UAH0C;QAI9DC,KAAK,EAAEzB;MAJuD,CAA3C,CAArB;IAMD,CAPD,CAOE,OAAOmB,KAAP,EAAc;MACd,IAAIjB,WAAW,CAACiB,KAAD,CAAf,EAAwB;QACtB,OAAO;UAAED,IAAI,EAAE;YAAEQ,IAAI,EAAE;UAAR,CAAR;UAAwBP;QAAxB,CAAP;MACD;;MAED,MAAMA,KAAN;IACD;EACF;EAED;;;;;;;;;EAOkB,MAAZQ,YAAY,CAACC,MAAD,EAA2B;IAC3C,IAAI;MACF,MAAM;QAAEN;MAAF,IAAuBM,MAA7B;MAAA,MAAoBC,IAAI,UAAKD,MAAL,EAAlB,WAAkB,CAAxB;;MACA,MAAML,IAAI,mCAAaM,IAAb,GAAsBP,OAAtB,CAAV;;MACA,IAAI,cAAcO,IAAlB,EAAwB;QACtB;QACAN,IAAI,CAACO,SAAL,GAAiBD,IAAI,SAAJ,QAAI,WAAJ,GAAI,MAAJ,OAAI,CAAEE,QAAvB;QACA,OAAOR,IAAI,CAAC,UAAD,CAAX;MACD;;MACD,OAAO,MAAMxB,QAAQ,CAAC,KAAKQ,KAAN,EAAa,MAAb,EAAqB,GAAG,KAAKF,GAAG,sBAAhC,EAAwD;QAC3EkB,IAAI,EAAEA,IADqE;QAE3EjB,OAAO,EAAE,KAAKA,OAF6D;QAG3EmB,KAAK,EAAE5B,qBAHoE;QAI3E2B,UAAU,EAAEF,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEE;MAJsD,CAAxD,CAArB;IAMD,CAdD,CAcE,OAAOL,KAAP,EAAc;MACd,IAAIjB,WAAW,CAACiB,KAAD,CAAf,EAAwB;QACtB,OAAO;UACLD,IAAI,EAAE;YACJc,UAAU,EAAE,IADR;YAEJN,IAAI,EAAE;UAFF,CADD;UAKLP;QALK,CAAP;MAOD;;MACD,MAAMA,KAAN;IACD;EACF,CAxHgC,CA0HjC;;EACA;;;;;;EAIgB,MAAVc,UAAU,CAACC,UAAD,EAAgC;IAC9C,IAAI;MACF,OAAO,MAAMnC,QAAQ,CAAC,KAAKQ,KAAN,EAAa,MAAb,EAAqB,GAAG,KAAKF,GAAG,cAAhC,EAAgD;QACnEkB,IAAI,EAAEW,UAD6D;QAEnE5B,OAAO,EAAE,KAAKA,OAFqD;QAGnEmB,KAAK,EAAEzB;MAH4D,CAAhD,CAArB;IAKD,CAND,CAME,OAAOmB,KAAP,EAAc;MACd,IAAIjB,WAAW,CAACiB,KAAD,CAAf,EAAwB;QACtB,OAAO;UAAED,IAAI,EAAE;YAAEQ,IAAI,EAAE;UAAR,CAAR;UAAwBP;QAAxB,CAAP;MACD;;MAED,MAAMA,KAAN;IACD;EACF;EAED;;;;;;;;EAMe,MAATgB,SAAS,CACbP,MADa,EACM;;;IAKnB,IAAI;MACF,MAAMQ,UAAU,GAAe;QAAEC,QAAQ,EAAE,IAAZ;QAAkBC,QAAQ,EAAE,CAA5B;QAA+BC,KAAK,EAAE;MAAtC,CAA/B;MACA,MAAMC,QAAQ,GAAG,MAAMzC,QAAQ,CAAC,KAAKQ,KAAN,EAAa,KAAb,EAAoB,GAAG,KAAKF,GAAG,cAA/B,EAA+C;QAC5EC,OAAO,EAAE,KAAKA,OAD8D;QAE5EW,aAAa,EAAE,IAF6D;QAG5EwB,KAAK,EAAE;UACLC,IAAI,EAAE,kBAAM,SAAN,UAAM,WAAN,GAAM,MAAN,SAAM,CAAEA,IAAR,MAAY,IAAZ,IAAYC,aAAZ,GAAY,MAAZ,GAAYA,GAAEC,QAAF,EAAZ,MAAwB,IAAxB,IAAwBC,aAAxB,GAAwBA,EAAxB,GAA4B,EAD7B;UAELC,QAAQ,EAAE,kBAAM,SAAN,UAAM,WAAN,GAAM,MAAN,SAAM,CAAEC,OAAR,MAAe,IAAf,IAAeC,aAAf,GAAe,MAAf,GAAeA,GAAEJ,QAAF,EAAf,MAA2B,IAA3B,IAA2BK,aAA3B,GAA2BA,EAA3B,GAA+B;QAFpC,CAHqE;QAO5ExB,KAAK,EAAE3B;MAPqE,CAA/C,CAA/B;MASA,IAAI0C,QAAQ,CAACrB,KAAb,EAAoB,MAAMqB,QAAQ,CAACrB,KAAf;MAEpB,MAAM+B,KAAK,GAAG,MAAMV,QAAQ,CAACW,IAAT,EAApB;MACA,MAAMZ,KAAK,GAAG,cAAQ,CAACjC,OAAT,CAAiB8C,GAAjB,CAAqB,eAArB,OAAqC,IAArC,IAAqCC,aAArC,GAAqCA,EAArC,GAAyC,CAAvD;MACA,MAAMC,KAAK,GAAG,oBAAQ,CAAChD,OAAT,CAAiB8C,GAAjB,CAAqB,MAArB,OAA4B,IAA5B,IAA4BG,aAA5B,GAA4B,MAA5B,GAA4BA,GAAEC,KAAF,CAAQ,GAAR,CAA5B,MAAwC,IAAxC,IAAwCC,aAAxC,GAAwCA,EAAxC,GAA4C,EAA1D;;MACA,IAAIH,KAAK,CAACI,MAAN,GAAe,CAAnB,EAAsB;QACpBJ,KAAK,CAACK,OAAN,CAAeC,IAAD,IAAiB;UAC7B,MAAMlB,IAAI,GAAGmB,QAAQ,CAACD,IAAI,CAACJ,KAAL,CAAW,GAAX,EAAgB,CAAhB,EAAmBA,KAAnB,CAAyB,GAAzB,EAA8B,CAA9B,EAAiCM,SAAjC,CAA2C,CAA3C,EAA8C,CAA9C,CAAD,CAArB;UACA,MAAMC,GAAG,GAAGC,IAAI,CAACC,KAAL,CAAWL,IAAI,CAACJ,KAAL,CAAW,GAAX,EAAgB,CAAhB,EAAmBA,KAAnB,CAAyB,GAAzB,EAA8B,CAA9B,CAAX,CAAZ;UACApB,UAAU,CAAC,GAAG2B,GAAG,MAAP,CAAV,GAA2BrB,IAA3B;QACD,CAJD;QAMAN,UAAU,CAACG,KAAX,GAAmBsB,QAAQ,CAACtB,KAAD,CAA3B;MACD;;MACD,OAAO;QAAErB,IAAI,kCAAOgC,KAAP,GAAiBd,UAAjB,CAAN;QAAqCjB,KAAK,EAAE;MAA5C,CAAP;IACD,CA1BD,CA0BE,OAAOA,KAAP,EAAc;MACd,IAAIjB,WAAW,CAACiB,KAAD,CAAf,EAAwB;QACtB,OAAO;UAAED,IAAI,EAAE;YAAEgC,KAAK,EAAE;UAAT,CAAR;UAAuB/B;QAAvB,CAAP;MACD;;MACD,MAAMA,KAAN;IACD;EACF;EAED;;;;;;;;;EAOiB,MAAX+C,WAAW,CAACC,GAAD,EAAY;IAC3B,IAAI;MACF,OAAO,MAAMpE,QAAQ,CAAC,KAAKQ,KAAN,EAAa,KAAb,EAAoB,GAAG,KAAKF,GAAG,gBAAgB8D,GAAG,EAAlD,EAAsD;QACzE7D,OAAO,EAAE,KAAKA,OAD2D;QAEzEmB,KAAK,EAAEzB;MAFkE,CAAtD,CAArB;IAID,CALD,CAKE,OAAOmB,KAAP,EAAc;MACd,IAAIjB,WAAW,CAACiB,KAAD,CAAf,EAAwB;QACtB,OAAO;UAAED,IAAI,EAAE;YAAEQ,IAAI,EAAE;UAAR,CAAR;UAAwBP;QAAxB,CAAP;MACD;;MAED,MAAMA,KAAN;IACD;EACF;EAED;;;;;;;;;EAOoB,MAAdiD,cAAc,CAACD,GAAD,EAAcjC,UAAd,EAA6C;IAC/D,IAAI;MACF,OAAO,MAAMnC,QAAQ,CAAC,KAAKQ,KAAN,EAAa,KAAb,EAAoB,GAAG,KAAKF,GAAG,gBAAgB8D,GAAG,EAAlD,EAAsD;QACzE5C,IAAI,EAAEW,UADmE;QAEzE5B,OAAO,EAAE,KAAKA,OAF2D;QAGzEmB,KAAK,EAAEzB;MAHkE,CAAtD,CAArB;IAKD,CAND,CAME,OAAOmB,KAAP,EAAc;MACd,IAAIjB,WAAW,CAACiB,KAAD,CAAf,EAAwB;QACtB,OAAO;UAAED,IAAI,EAAE;YAAEQ,IAAI,EAAE;UAAR,CAAR;UAAwBP;QAAxB,CAAP;MACD;;MAED,MAAMA,KAAN;IACD;EACF;EAED;;;;;;;;;;;EASgB,MAAVkD,UAAU,CAACC,EAAD,EAAqC;IAAA,IAAxBC,gBAAwB,uEAAL,KAAK;;IACnD,IAAI;MACF,OAAO,MAAMxE,QAAQ,CAAC,KAAKQ,KAAN,EAAa,QAAb,EAAuB,GAAG,KAAKF,GAAG,gBAAgBiE,EAAE,EAApD,EAAwD;QAC3EhE,OAAO,EAAE,KAAKA,OAD6D;QAE3EiB,IAAI,EAAE;UACJiD,kBAAkB,EAAED;QADhB,CAFqE;QAK3E9C,KAAK,EAAEzB;MALoE,CAAxD,CAArB;IAOD,CARD,CAQE,OAAOmB,KAAP,EAAc;MACd,IAAIjB,WAAW,CAACiB,KAAD,CAAf,EAAwB;QACtB,OAAO;UAAED,IAAI,EAAE;YAAEQ,IAAI,EAAE;UAAR,CAAR;UAAwBP;QAAxB,CAAP;MACD;;MAED,MAAMA,KAAN;IACD;EACF;;EAEyB,MAAZT,YAAY,CACxBkB,MADwB,EACa;IAErC,IAAI;MACF,MAAM;QAAEV,IAAF;QAAQC;MAAR,IAAkB,MAAMpB,QAAQ,CACpC,KAAKQ,KAD+B,EAEpC,KAFoC,EAGpC,GAAG,KAAKF,GAAG,gBAAgBuB,MAAM,CAAC6C,MAAM,UAHJ,EAIpC;QACEnE,OAAO,EAAE,KAAKA,OADhB;QAEEmB,KAAK,EAAGiD,OAAD,IAAiB;UACtB,OAAO;YAAExD,IAAI,EAAE;cAAEwD;YAAF,CAAR;YAAqBvD,KAAK,EAAE;UAA5B,CAAP;QACD;MAJH,CAJoC,CAAtC;MAWA,OAAO;QAAED,IAAF;QAAQC;MAAR,CAAP;IACD,CAbD,CAaE,OAAOA,KAAP,EAAc;MACd,IAAIjB,WAAW,CAACiB,KAAD,CAAf,EAAwB;QACtB,OAAO;UAAED,IAAI,EAAE,IAAR;UAAcC;QAAd,CAAP;MACD;;MAED,MAAMA,KAAN;IACD;EACF;;EAE0B,MAAbN,aAAa,CACzBe,MADyB,EACa;IAEtC,IAAI;MACF,MAAMV,IAAI,GAAG,MAAMnB,QAAQ,CACzB,KAAKQ,KADoB,EAEzB,QAFyB,EAGzB,GAAG,KAAKF,GAAG,gBAAgBuB,MAAM,CAAC6C,MAAM,YAAY7C,MAAM,CAAC0C,EAAE,EAHpC,EAIzB;QACEhE,OAAO,EAAE,KAAKA;MADhB,CAJyB,CAA3B;MASA,OAAO;QAAEY,IAAF;QAAQC,KAAK,EAAE;MAAf,CAAP;IACD,CAXD,CAWE,OAAOA,KAAP,EAAc;MACd,IAAIjB,WAAW,CAACiB,KAAD,CAAf,EAAwB;QACtB,OAAO;UAAED,IAAI,EAAE,IAAR;UAAcC;QAAd,CAAP;MACD;;MAED,MAAMA,KAAN;IACD;EACF;;AAnTgC","names":["_generateLinkResponse","_noResolveJsonResponse","_request","_userResponse","resolveFetch","isAuthError","GoTrueAdminApi","constructor","url","headers","fetch","mfa","listFactors","_listFactors","bind","deleteFactor","_deleteFactor","signOut","jwt","scope","noResolveJson","data","error","inviteUserByEmail","email","options","body","redirectTo","xform","user","generateLink","params","rest","new_email","newEmail","properties","createUser","attributes","listUsers","pagination","nextPage","lastPage","total","response","query","page","_a","toString","_b","per_page","perPage","_c","_d","users","json","get","_e","links","_f","split","_g","length","forEach","link","parseInt","substring","rel","JSON","parse","getUserById","uid","updateUserById","deleteUser","id","shouldSoftDelete","should_soft_delete","userId","factors"],"sources":["C:\\Users\\unaiz\\Desktop\\codepath_tf\\web102\\activity\\lab\\web102_unit7lab\\client\\node_modules\\@supabase\\auth-js\\src\\GoTrueAdminApi.ts"],"sourcesContent":["import {\n  Fetch,\n  _generateLinkResponse,\n  _noResolveJsonResponse,\n  _request,\n  _userResponse,\n} from './lib/fetch'\nimport { resolveFetch } from './lib/helpers'\nimport {\n  AdminUserAttributes,\n  GenerateLinkParams,\n  GenerateLinkResponse,\n  Pagination,\n  User,\n  UserResponse,\n  GoTrueAdminMFAApi,\n  AuthMFAAdminDeleteFactorParams,\n  AuthMFAAdminDeleteFactorResponse,\n  AuthMFAAdminListFactorsParams,\n  AuthMFAAdminListFactorsResponse,\n  PageParams,\n} from './lib/types'\nimport { AuthError, isAuthError } from './lib/errors'\n\nexport default class GoTrueAdminApi {\n  /** Contains all MFA administration methods. */\n  mfa: GoTrueAdminMFAApi\n\n  protected url: string\n  protected headers: {\n    [key: string]: string\n  }\n  protected fetch: Fetch\n\n  constructor({\n    url = '',\n    headers = {},\n    fetch,\n  }: {\n    url: string\n    headers?: {\n      [key: string]: string\n    }\n    fetch?: Fetch\n  }) {\n    this.url = url\n    this.headers = headers\n    this.fetch = resolveFetch(fetch)\n    this.mfa = {\n      listFactors: this._listFactors.bind(this),\n      deleteFactor: this._deleteFactor.bind(this),\n    }\n  }\n\n  /**\n   * Removes a logged-in session.\n   * @param jwt A valid, logged-in JWT.\n   * @param scope The logout sope.\n   */\n  async signOut(\n    jwt: string,\n    scope: 'global' | 'local' | 'others' = 'global'\n  ): Promise<{ data: null; error: AuthError | null }> {\n    try {\n      await _request(this.fetch, 'POST', `${this.url}/logout?scope=${scope}`, {\n        headers: this.headers,\n        jwt,\n        noResolveJson: true,\n      })\n      return { data: null, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Sends an invite link to an email address.\n   * @param email The email address of the user.\n   * @param options Additional options to be included when inviting.\n   */\n  async inviteUserByEmail(\n    email: string,\n    options: {\n      /** A custom data object to store additional metadata about the user. This maps to the `auth.users.user_metadata` column. */\n      data?: object\n\n      /** The URL which will be appended to the email link sent to the user's email address. Once clicked the user will end up on this URL. */\n      redirectTo?: string\n    } = {}\n  ): Promise<UserResponse> {\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/invite`, {\n        body: { email, data: options.data },\n        headers: this.headers,\n        redirectTo: options.redirectTo,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Generates email links and OTPs to be sent via a custom email provider.\n   * @param email The user's email.\n   * @param options.password User password. For signup only.\n   * @param options.data Optional user metadata. For signup only.\n   * @param options.redirectTo The redirect url which should be appended to the generated link\n   */\n  async generateLink(params: GenerateLinkParams): Promise<GenerateLinkResponse> {\n    try {\n      const { options, ...rest } = params\n      const body: any = { ...rest, ...options }\n      if ('newEmail' in rest) {\n        // replace newEmail with new_email in request body\n        body.new_email = rest?.newEmail\n        delete body['newEmail']\n      }\n      return await _request(this.fetch, 'POST', `${this.url}/admin/generate_link`, {\n        body: body,\n        headers: this.headers,\n        xform: _generateLinkResponse,\n        redirectTo: options?.redirectTo,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: {\n            properties: null,\n            user: null,\n          },\n          error,\n        }\n      }\n      throw error\n    }\n  }\n\n  // User Admin API\n  /**\n   * Creates a new user.\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async createUser(attributes: AdminUserAttributes): Promise<UserResponse> {\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/admin/users`, {\n        body: attributes,\n        headers: this.headers,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Get a list of users.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.\n   */\n  async listUsers(\n    params?: PageParams\n  ): Promise<\n    | { data: { users: User[]; aud: string } & Pagination; error: null }\n    | { data: { users: [] }; error: AuthError }\n  > {\n    try {\n      const pagination: Pagination = { nextPage: null, lastPage: 0, total: 0 }\n      const response = await _request(this.fetch, 'GET', `${this.url}/admin/users`, {\n        headers: this.headers,\n        noResolveJson: true,\n        query: {\n          page: params?.page?.toString() ?? '',\n          per_page: params?.perPage?.toString() ?? '',\n        },\n        xform: _noResolveJsonResponse,\n      })\n      if (response.error) throw response.error\n\n      const users = await response.json()\n      const total = response.headers.get('x-total-count') ?? 0\n      const links = response.headers.get('link')?.split(',') ?? []\n      if (links.length > 0) {\n        links.forEach((link: string) => {\n          const page = parseInt(link.split(';')[0].split('=')[1].substring(0, 1))\n          const rel = JSON.parse(link.split(';')[1].split('=')[1])\n          pagination[`${rel}Page`] = page\n        })\n\n        pagination.total = parseInt(total)\n      }\n      return { data: { ...users, ...pagination }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { users: [] }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Get user by id.\n   *\n   * @param uid The user's unique identifier\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async getUserById(uid: string): Promise<UserResponse> {\n    try {\n      return await _request(this.fetch, 'GET', `${this.url}/admin/users/${uid}`, {\n        headers: this.headers,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Updates the user data.\n   *\n   * @param attributes The data you want to update.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async updateUserById(uid: string, attributes: AdminUserAttributes): Promise<UserResponse> {\n    try {\n      return await _request(this.fetch, 'PUT', `${this.url}/admin/users/${uid}`, {\n        body: attributes,\n        headers: this.headers,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Delete a user. Requires a `service_role` key.\n   *\n   * @param id The user id you want to remove.\n   * @param shouldSoftDelete If true, then the user will be soft-deleted (setting `deleted_at` to the current timestamp and disabling their account while preserving their data) from the auth schema.\n   * Defaults to false for backward compatibility.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async deleteUser(id: string, shouldSoftDelete = false): Promise<UserResponse> {\n    try {\n      return await _request(this.fetch, 'DELETE', `${this.url}/admin/users/${id}`, {\n        headers: this.headers,\n        body: {\n          should_soft_delete: shouldSoftDelete,\n        },\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  private async _listFactors(\n    params: AuthMFAAdminListFactorsParams\n  ): Promise<AuthMFAAdminListFactorsResponse> {\n    try {\n      const { data, error } = await _request(\n        this.fetch,\n        'GET',\n        `${this.url}/admin/users/${params.userId}/factors`,\n        {\n          headers: this.headers,\n          xform: (factors: any) => {\n            return { data: { factors }, error: null }\n          },\n        }\n      )\n      return { data, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  private async _deleteFactor(\n    params: AuthMFAAdminDeleteFactorParams\n  ): Promise<AuthMFAAdminDeleteFactorResponse> {\n    try {\n      const data = await _request(\n        this.fetch,\n        'DELETE',\n        `${this.url}/admin/users/${params.userId}/factors/${params.id}`,\n        {\n          headers: this.headers,\n        }\n      )\n\n      return { data, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}